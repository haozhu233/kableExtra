---
title: "\\LaTeX{} tables with `tabularray`"
subtitle: ""
format: 
  pdf:
    toc: true
    toc-depth: 1
---

\clearpage

This vignette demonstrates how to harness the capabilities of `tabularray` and `kableExtra` for crafting advanced \LaTeX{} tables in `R`. The integration of `kableExtra` with `tabularray` brings a host of benefits, including versatile cell alignment and the ability to create colorful, multirow, and multicolumn tables. The guide covers controlling rows, columns, cells, line manipulation, table width management, and more. Our aim is to equip users with the knowledge to create visually appealing and well-structured \LaTeX{} tables.

[Click here to visit the `tabularray` website and read its documentation.](https://ctan.org/pkg/tabularray?lang=en)

To create tables with `tabularray` in `kableExtra`, users only need to set the `tabular` argument of the `kbl` function:

```{r}
library(kableExtra)

df <- data.frame(
  car = row.names(mtcars),
  mtcars[, 1:3],
  row.names = NULL
)[1:4,]

kbl(df, tabular = "tblr", booktabs = TRUE)
```


# Why?

`kableExtra` supports the `tabularray` package for \LaTeX{} to create tables with advanced formatting options. Using this tabular environments allows us to circumvent several nagging bugs in `kableExtra` output, and opens many new possibilities. `tabularray` offers several benefits:

- Versatile cell alignment
- Multirow and multicolumn support
- Flexible column types
- Advanced line customization
- Colorful table options
- Improved vertical spacing
- Compatibility with \LaTeX3
- Support for long tables
- Integration with popular \LaTeX{} libraries

One of the most important advantages of using `tabularray` is that code generated by `kableExtra` is very readable, and much easier to edit manually than when using other \LaTeX{} packages. For example, here is the code for a table with colored and bolded rows:

```{r}
kbl(df, tabular = "tblr", booktabs = TRUE) |> 
  row_spec(2:3, bold = TRUE, background = "pink") |>
  cat()
```

Here are some of the important things to notice:

* The tabular environment starts with `\being{tblr}` and ends with `\end{tblr}`.
* The data and style are completely independent: The tabular content is untouched, and we add `colspec` and `rowspec` headers to specify the style.
* Each row and each column gets a `Q[]` entry, which acts as a styling operator. We can insert arguments in the square brackets to change the style of all the cells in a column or row. The available arguments [are described in the `tabularray` documentation.](https://ctan.org/pkg/tabularray?lang=en)

In contrast, when using other \LaTeX{} packages, each entry of the table must be modified, which arguably makes the code messier and harder to edit:

```{r}
kbl(df, booktabs = TRUE) |> 
  row_spec(2:3, bold = TRUE, background = "pink") |>
  cat()
```

# Preamble

When rendering Rmarkdown or Quarto documents, appropriate packages are automatically loaded. When compiling \LaTeX{} documents, users must add these commands to their preamble:

```latex
\usepackage{tabularray}
\newcommand{\\kableExtraTabularrayUnderline}[1]{\underline}
\newcommand{\\kableExtraTabularrayStrikeout}[1]{\sout}
\UseTblrLibrary{booktabs}
```

# Text styles

The core functions to modify text styles in `kableExtra` are `cell_spec()`, `row_spec()`, and `column_spec()`. All the arguments of these functions are supported, except for 3 arguments of the `row_spec()` function: `angle`, `font_size`, and `align`. Users can achieve a similar effect using the `cell_spec()` function (see the section below on cell-specific settings).

Here is an example of a table with bold text and strikethroughs:

```{r}
kbl(df, tabular = "tblr", booktabs = TRUE) |>
  row_spec(2:3, bold = TRUE) |>
  column_spec(1, strikeout = TRUE)
```

# Colors

In `tabularray`, color names are supported through the integration of the `xcolor` and `ninecolors` packages. The `xcolor` package is a comprehensive solution in LaTeX for color customization, offering a wide range of predefined color names and the ability to define custom colors using various color models like RGB, CMYK, and HTML. This flexibility allows for precise color specification and is ideal for setting text, table elements, and other document components in LaTeX.

The basic \LaTeX{} colors are: black, blue, brown, cyan, darkgray, gray, green, lightgray, lime, magenta, olive, orange, pink, purple, red, teal, violet, white, yellow. 

The [`ninecolors`](https://ctan.org/pkg/ninecolors) package adds suffix to 9 of those colors to set 1 of 13 different hues: gray, red, brown, yellow, olive, green, teal, cyan, azure, blue, violet, magenta, purple. For all colors, 0 means black, and 10 is white. Two colors with the same numbered suffix have the same luminance (ex: `gray3` and `olive3`).  These nine colors are carefully selected to ensure proper color contrast according to the Web Content Accessibility Guidelines (WCAG). This feature is particularly useful for creating documents with high readability and accessibility standards. To get proper WCAG Color Contrast, the `ninecolors` author recommends choosing two colors with different names, with at least a 5 unit difference in level.

The `col_spec()`, `row_spec()`, and `cell_spec()` functions support these colors out of the box:

```{r}
df |>
  kbl(tabular = "tblr", booktabs = TRUE) |>
  column_spec(1, color = "green!30!black") |>
  row_spec(2:3, background = "azure9")
```

Of course, `kableExtra` themes are also supported:

```{r}
df |>
  kbl(tabular = "tblr", booktabs = TRUE) |>
  kable_styling(latex_options = "striped")
```


# Precedence

In some contexts, user-specified settings like cell colors or text styles enter in conflict. In such cases, these two rules are applied:

1. `cell_spec()` settings have the highest precedence.
2. The last function call  determines if row or column settings have precedence: `column_spec()` vs `row_spec()`

In the following example, we define conflicting background colors at the cell, column, and row level. In that case, the cell wins. When there is only a conflict between rows and columns, rows win because `row_spec()` is called after `column_spec()`.

```{r}
df2 <- df
df2[1, 1] <- cell_spec(df2[1, 1], background = "yellow", format = "tblr")
kbl(df2, tabular = "tblr", escape = FALSE, booktabs = TRUE) |>
    column_spec(1:2, background = "pink") |>
    row_spec(1:2, background = "azure8")
```


# Width

This example illustrates how to customize the width of a single columns, while expanding the rest of the table to fill the entire page width:

```{r}
kbl(df, tabular = "tblr", align = "lccc", booktabs = TRUE) |>
    kable_styling(full_width = TRUE) |>
    column_spec(1, width = "8cm")
```

Under the hood, to fix the width of certain columns or expand the table to full page width, `kableExtra` can use `X` or `Q` columns in `tabularray`. `X` columns are designed for scenarios where you want the table columns to automatically adjust their widths to fill the entire available space. This feature is particularly useful for creating tables that span the full width of a page or container. When you use `X` columns, the width of each column is proportionally divided based on the available space, allowing for a responsive and evenly distributed layout.  On the other hand, `Q` columns function like the standard `p` columns in \LaTeX, where you manually specify the width of each column. The content in these columns is wrapped to fit within the set width. This type of column is ideal when precise control over column width is needed, such as in tables with varying content lengths or specific design requirements.

When using the `kable_styling()` function in R for \LaTeX{} output and setting `full_width = TRUE`, the table automatically employs `X` columns. This configuration makes the table expand to fill the width of its container, with each column adjusting its width to fit proportionally. This is a key feature for creating full-width tables that need to be responsive and aesthetically balanced in their layout.


# Cell specification

To apply cell-specific settings, we can use the `cell_spec()` function. In `kbl()`, it is necessary to use `escape=TRUE` and `tabular="tblr"`. In `cell_spec()`, it is necessary to use `tabular="tblr"`:

```{r}
df2 <- df
df2[2, 2] <- cell_spec(
  df2[2, 2],
  background = "pink",
  align = "c",
  color = "azure2",
  font_size = 20,
  angle = 45,
  format = "tblr")

kbl(df2, tabular = "tblr", escape = FALSE, booktabs = TRUE)
```

# Long tables

```{r}
cities <- c(
"Toronto", "Montreal", "Vancouver", "Calgary", "Edmonton", "Ottawa",
"Winnipeg", "Quebec City", "Hamilton", "Kitchener", "London", "Victoria",
"Halifax", "Oshawa", "Windsor", "Saskatoon", "Regina", "St. John's",
"Sudbury", "Sherbrooke", "Barrie", "Kelowna", "Abbotsford", "Kingston",
"Guelph", "Moncton", "Brantford", "Saint John", "Thunder Bay", "Peterborough",
"Lethbridge", "Kamloops", "Nanaimo", "Sarnia", "Saint-Jean-sur-Richelieu",
"Red Deer", "Chilliwack", "Sault Ste. Marie", "Drummondville", "Fredericton"
)
df2 <- data.frame(
  city = cities,
  numbers = sprintf("%.5f", rnorm(40))
)

kbl(df2, tabular = "longtblr", caption = "Blah blah", booktabs = TRUE) |>
  kable_styling()
```

# Tall tables

```{r}
kbl(df, tabular = "talltblr", caption = "Blah blah", booktabs = TRUE) |>
  kable_styling(latex_options = "HOLD_position")
```

# `tabularray` options

The [`tabularray` document describes many options and arguments](https://ctan.org/pkg/tabularray?lang=en) to control cells, rows, and columns of a table.

There are two different types of options in `tabularray`: inner and outer. The inner options are defined in curly braces. The outer options are defined in square brackets. Consider this `longtblr` in which we specify both an inner (`rowhead`) and an outer (`entry`) option:

```latex
\begin{longtblr}[
  headsep = 12pt,
]{
  colspec = {Q[bg=pink]Q[bg=yellow]},
  rowhead = 2,
}
\hline
Car & mpg \\
\hline
Mazda RX4 & 21.0 \\
Mazda RX4 Wag & 21.0 \\
\hline
\end{longtblr}
```

Both types of options can be set using `kable_styling()` function and its `latex_options` argument:

```{r}
kbl(df, tabular = "talltblr", booktabs = TRUE) |>
  kable_styling(latex_options = list(tabularray_outer = c(
    "caption = {A caption.}",
    "label = {tab:mytable}",
    "headsep = 12pt"
  )))
```

The mechanism above sets options at the table-level. Unfortunately, `kableExtra` does not have a direct way to set inner options at the row, column or cell-level. However, it is easy to hack our way around this limitation to set inner options at any level we want: columns, rows, or cells.

For example, the `row_spec()` function from `kableExtra` does not have an argument to control the height of columns, but `tabularray` does have an inner option: `ht`. To insert this in the row settings, we can push `ht` through the existing `background` argument of `row_spec()`. To understand how this works, note that when we call `background="red"`, `kableExtra` simply adds a string to the `rowspec` header: `fg=red`. If we extend the `background` entry, then we can specify height and vertical alignment too. Here, we use `f` for "foot" (also: `h`, `m`) and specify the height in `em` units (also: `cm`, `pt`, `in`):

```{r}
kbl(df, tabular = "tblr", booktabs = TRUE) |>
  row_spec(2, background = "pink, ht=3.5em, valign=f") 
```

The code for this table is printed below. You will note that the `rowspec` line has been modified: The second row will now be taller, and the text will be foot-aligned.

```{r, echo = FALSE}
kbl(df, tabular = "tblr", booktabs = TRUE) |>
  row_spec(2, background = "pink, ht=3.5em, valign=f") |>
  cat()
```

# Lines

 The `tabularray` package offers advanced table formatting options in \LaTeX{}, especially for vertical and horizontal lines. The syntax to control these lines is slightly different than for other output format in `kableExtra`, so it deserves some explanation. Consider this example:

```{r}
kbl(df, tabular = "tblr", vline = "", linesep = "",
    toprule = "", midrule = "", bottomrule = "") |>
  kable_styling(
    latex_options = list(tabularray_inner = c(
      "hlines={dash=dotted, fg=brown6}",
      "vlines={dash=dashed, fg=green4, wd=2pt}"
    ))
  )
```

To achieve this result, we began by removing the default horizontal rules (`toprule`, `midrule`, `bottomrule`), otherwise, there would be double horizontal lines in the table. Then, we use `kable_styling()` with the `latex_options` argument to specify a vector of `tabularray` options.

When `vlines` and `hlines` are in plural form, they control all lines in the table. `tabularray` also supports another syntax for specifying individual lines. For example, we can control the color, width, and type of lines as follows:

```{r}
kbl(df, tabular = "tblr", vline = "",
    toprule = "", midrule = "", bottomrule = "", linesep = "") |>
  kable_styling(
    latex_options = list(tabularray_inner = c(
      "hline{1-6}={dash=solid, fg=brown6}",
      "vline{2,3}={dash=dotted, fg=green4}"
    ))
  )
```

Of course, we can still use the usual `kableExtra` interface:

```{r}
kbl(mtcars[1:5, 1:4],
    tabular = "tblr",
    booktabs = TRUE,
    vline = "",
    toprule = "\\toprule[4pt, lightgray]",
    midrule = "\\midrule[3pt, lightgray]",
    bottomrule = "\\bottomrule[5pt, orange]",
    linesep = "\\midrule[2pt, lightgray]")
```

Unfortunately, commands like this do not appear to be recognized by `tabularray`:

```latex
\\arrayrulecolor{lightgray}\\midrule[2pt]
```

# Footnotes and remarks

The `footnote()` function from `kableExtra` works as expected, including the `threepartable` argument:

```{r}
lorem <- paste(c(
"Lorem ipsum dolor sit amet, consectetur adipiscing elit.  Aliquam",
"molestie, leo in placerat tristique, nisi diam laoreet lorem, molestie venenatis",
"ex elit non leo. Vivamus posuere ligula quis felis vehicula, porta consectetur",
"tortor fringilla. Fusce gravida venenatis consectetur. Sed a odio metus. Sed",
"egestas dui sed justo accumsan volutpat. Phasellus a mollis dolor. Morbi luctus",
"nibh at erat interdum, sed rutrum eros ultrices. Suspendisse at bibendum nibh.",
"Duis sit amet nisi nec nisl pretium volutpat sed ut elit. Donec ultricies",
"dapibus dolor, non congue purus vestibulum sit amet. Etiam molestie libero in."),
collapse = " ")

kbl(df, tabular = "tblr", caption = "Blah blah") |>
  kable_styling(full_width = TRUE, latex_options = "HOLD_position") |>
  footnote(
    threeparttable = TRUE,
    general = lorem) 
```

In addition, `tabularray` includes its own mechanism to append notes and remarks to the bottom of tables in the `longtblr` and `talltblr` formats. To insert a footnote with a marker inside a specific cell of the table, we insert a `\TblrNote{}` command inside the cell, and use `note` and/or `remark` in the `latex_options`:

```{r}
df <- data.frame(
    blah = c("blah blah\\TblrNote{$\\dag$}", "blah blah blah"), 
    location = c("Montreal", "Quebec")
)
kbl(df, tabular = "talltblr", escape = FALSE) |>
    kable_styling(
        latex_options = list(tabularray_outer = c(
            "caption={A caption.}",
            "remark{Source}={A remark.}",
            "remark{Note}={Another remark.}",
            "note{$\\dag$}={A note.}")
            )
    )
```

# `add_header_above()`

The `add_header_above()` function can create spanning column labels using the `\SetCel[c=2]{}` command from `tabularray`:

```{r}
mtcars[1:4, 1:5] |>
    kbl(tabular = "tblr", align = "c", booktabs = TRUE) |> 
    add_header_above(
        c(" " = 1, "$\\alpha$" = 2, "$\\beta$" = 3),
        escape = FALSE) |>
    add_header_above(
        c( "First Three" = 3, " " = 1, "Penultimate" = 1, " " = 1),
        italic = TRUE)
```

# More examples

This section prints several commands for complex tables which were reported as difficult to draw in previous versions of `kableExtra`. The title of each section identifies the corresponding issue on [the issue tracker.](https://github.com/haozhu233/kableExtra/issues)

## Issue #616

```{r}
mtcars %>%
  head(n = 10) %>%
  kbl(tabular = "tblr") %>%
  kable_styling(latex_options = "HOLD_position") |>
  row_spec(seq(1, 10, by = 2), background = "gray8, ht=1cm") |>
  row_spec(seq(2, 10, by = 2), background = "white, ht=1cm")
```

## Issue #634

```{r}
cs_dt <- mtcars[1:10, 1:2]
cs_dt$mpg = cell_spec(cs_dt$mpg, align = "c")
kbl(cs_dt, tabular = "tblr", escape = FALSE) %>%
  kable_styling(latex_options = "striped")
```

## Issue #636

```{r}
set.seed(1024)
paint <- function(x) {
  col <- ifelse(x < 0.5, "yellow", "red")
  sapply(seq_along(x), function(i) cell_spec(
    formatC(x[i], format = "f", digits = 2),
    background = col[i], format = "tblr")
  )
}
DF <- data.frame(
  V1 = sample(letters,10,T),
  V2 = abs(rnorm(10)),
  V3 = abs(rnorm(10)))
DF[,-1] = lapply(DF[,-1], paint)

kbl(DF, tabular = "tblr", digits = 2, escape = FALSE) |>
  kable_styling(latex_options = "striped")
```

## Issue #645

```{r}
mtcars[1:3, 1:3] |>
  kbl(tabular = "tblr", booktabs = TRUE) |>
  row_spec(0, background = "teal3", bold = TRUE, color = "white")
```

## Issue #660

```{r}
kbl(mtcars[1:7, ], align = "c", tabular = "tblr", booktabs = TRUE) %>%
  kable_styling(
    latex_options = c("striped", "HOLD_position"),
    full_width = TRUE) %>%
  column_spec(1, width = "4cm")
```


## Issue #701

```{r}
dt <- data.frame(
  title = c(rep("a", 3), rep("b", 3), rep("c", 3), rep("d", 3)),
  value = 1:12
)
kbl(dt, format = "latex", tabular = "tblr") |>
  collapse_rows(1, latex_hline = "none") |>
  pack_rows(index = c('a' = 3, 'b' = 3, 'c' = 3, 'd' = 3)) |>
  row_spec(c(1, 5, 9, 13), background = "gray8")
```

###  Issue #738

```{r}
t <- head(cars)
t$dist <- cell_spec(t$dist, background = "red", format = "tblr")
kbl(t, tabular = "tblr", escape = FALSE) |>
  kable_styling(latex_options = c("striped"))
```
