---
title: "`tabularray` and `kableExtra`: Flexible \\LaTeX{} tables"
output:
  pdf_document:
    keep_tex: true
    toc: true
---

\clearpage

This vignette requires this `kableExtra` development branch:

```r
remotes::install_github("vincentarelbundock/kableExtra@tabularray")
```

This vignette demonstrates how to harness the capabilities of `tabularray` and `kableExtra` for crafting advanced \LaTeX{} tables in R. Readers will learn to use the `kbl()` function for transforming data frames into sophisticated \LaTeX{} tables. The integration of `kableExtra` with `tabularray` brings a host of benefits, including versatile cell alignment and the ability to create colorful, multirow, and multicolumn tables. The guide covers controlling rows, columns, cells, line manipulation, and table width management, aiming to equip users with the knowledge to create responsive, visually appealing, and well-structured \LaTeX{} tables.

[Click here to visit the `tabularray` website and read its documentation.](https://ctan.org/pkg/tabularray?lang=en)

To create tables with `tabularray` in `kableExtra`, users only need to set the `tabular` argument of the `kbl` function:

```{r}
library(kableExtra)

df <- data.frame(Car = row.names(mtcars), mtcars[, 1:3])[1:4,]
row.names(df) <- NULL

kbl(df, tabular = "tblr")
```

# Why use `tabularray`?

`kableExtra` supports the `tabularray` package for \LaTeX{} to create tables with advanced formatting options. `tabularray` offers several benefits:

- Versatile cell alignment
- Multirow and multicolumn support
- Flexible column types
- Advanced line customization
- Colorful table options
- Improved vertical spacing
- Compatibility with \LaTeX3
- Support for long tables
- Integration with popular \LaTeX{} libraries

One of the most important benefits of using `tabularray` is that code generated by `kableExtra` is very readable, and much easier to edit manually than when using other \LaTeX{} packages. For example, here is the code for a table with colored and bolded rows:

```{r}
kbl(df, tabular = "tblr") |> 
  row_spec(2:3, bold = TRUE, background = "pink") |>
  cat()
```

Here are some of the important things to notice:

* The tabular environment starts with `\being{tblr}` and ends with `\end{tblr}`.
* The data and style are completely independent: The tabular content is untouched, and we add `colspec` and `rowspec` headers to specify the style.
* Each row and each column gets a `Q[]` entry, which acts as a styling operator. We can insert arguments in the square brackets to change the style of all the cells in a column or row. The available arguments [are described in the `tabularray` documentation.](https://ctan.org/pkg/tabularray?lang=en)

In contrast, when using other \LaTeX{} packages, each entry of the table must be modified, which arguably makes the code messier and harder to edit:

```{r}
kbl(df, format = "latex") |> 
  row_spec(2:3, bold = TRUE, background = "pink") |>
  cat()
```

# Text styles

The core functions to modify text styles in `kableExtra` are `cell_spec()`, `row_spec()`, and `column_spec()`. All the arguments of these functions are supported, except for 3 arguments of the `row_spec()` function: `angle`, `font_size`, and `align`. Users can achieve a similar effect using the `cell_spec()` function (see the section below on cell-specific settings).

Here is an example of a table with bold text and strikethroughs:

```{r}
kbl(df, tabular = "tblr") |>
  row_spec(2:3, bold = TRUE) |>
  column_spec(1, strikeout = TRUE)
```

# Colors

In `tabularray`, color names are supported through the integration of the `xcolor` and `ninecolors` packages. The `xcolor` package is a comprehensive solution in LaTeX for color customization, offering a wide range of predefined color names and the ability to define custom colors using various color models like RGB, CMYK, and HTML. This flexibility allows for precise color specification and is ideal for setting text, table elements, and other document components in LaTeX.

The basic \LaTeX{} colors are: black, blue, brown, cyan, darkgray, gray, green, lightgray, lime, magenta, olive, orange, pink, purple, red, teal, violet, white, yellow. 

The [`ninecolors`](https://ctan.org/pkg/ninecolors) package adds suffix to 9 of those colors to set 1 of 13 different hues: gray, red, brown, yellow, olive, green, teal, cyan, azure, blue, violet, magenta, purple. For all colors, 0 means black, and 10 is white. Two colors with the same numbered suffix have the same luminance (ex: `gray3` and `olive3`).  These nine colors are carefully selected to ensure proper color contrast according to the Web Content Accessibility Guidelines (WCAG). This feature is particularly useful for creating documents with high readability and accessibility standards. To get proper WCAG Color Contrast, the `ninecolors` author recommends choosing two colors with different names, with at least a 5 unit difference in level.

The `col_spec()`, `row_spec()`, and `cell_spec()` functions support these colors out of the box:

```{r}
df |>
  kbl(tabular = "tblr") |>
  column_spec(1, color = "purple3") |>
  row_spec(2:3, background = "azure9")
```

Of course, `kableExtra` themes are also supported:

```{r}
df |>
  kbl(tabular = "tblr") |>
  kable_styling(latex_options = "striped")
```


# Precedence: Rows, Columns, Cells

In some contexts, user-specified settings like cell colors or text styles enter in conflict. In such cases, these two rules are applied:

1. `cell_spec()` settings have the highest precendence.
2. The last function call (`column_spec()` or `row_spec()`) determines if row or column settings have precedence.

In the following example, we define conflicting background colors at the cell, column, and row level. In that case, the cell wins. When there is only a conflict between rows and columns, rows win because `row_spec()` is called after `column_spec()`.

```{r}
df2 <- df
df2[1, 1] <- cell_spec(df2[1, 1], background = "yellow", format = "tblr")
kbl(df2, tabular = "tblr", escape = FALSE) |>
    column_spec(1:2, background = "pink") |>
    row_spec(1:2, background = "azure8")
```

# Lines: Horizontal and Vertical

 The `tabularray` package offers advanced table formatting options in \LaTeX{}, especially for vertical and horizontal lines. The syntax to control these lines is slightly different than for other output format in `kableExtra`, so it deserves some explanation. Consider this example:

```{r}
kbl(df,
    tabular = "tblr",
    toprule = "", midrule = "", bottomrule = "",
    linesep = "hlines={dash=dotted, fg=brown6}",
    vline = "vlines={dash=dashed, fg=green4, wd=2pt}"
)
```

To achieve this result, we began by removing the default horizontal rules (`toprule`, `midrule`, `bottomrule`), otherwise, there would be double horizontal lines in the table. then, we use the `linesep` argument to tell `tabularray` how to format horizontal lines in the table, and the `vline` argument to control vertical lines. 

When `vlines` and `hlines` are in plural form, they control all lines in the table. `tabularray` also supports another syntax for specifying individual lines. For example, we can control the color, width, and type of lines as follows::

```{r}
kbl(df,
    tabular = "tblr",
    toprule = "", midrule = "", bottomrule = "",
    linesep = "hline{1-6}={dash=solid, fg=brown6}",
    vline = "vline{2,3}={dash=dotted, fg=green4}"
)
```


# Width: Columns and table

To fix the width of certain columns or expand the table to full page width, `kableExtra` can use `X` or `Q` columns in `tabularray`. `X` columns are designed for scenarios where you want the table columns to automatically adjust their widths to fill the entire available space. This feature is particularly useful for creating tables that span the full width of a page or container. When you use `X` columns, the width of each column is proportionally divided based on the available space, allowing for a responsive and evenly distributed layout.  On the other hand, `Q` columns function like the standard `p` columns in \LaTeX, where you manually specify the width of each column. The content in these columns is wrapped to fit within the set width. This type of column is ideal when precise control over column width is needed, such as in tables with varying content lengths or specific design requirements.

When using the `kable_styling()` function in R for \LaTeX{} output and setting `full_width = TRUE`, the table automatically employs `X` columns. This configuration makes the table expand to fill the width of its container, with each column adjusting its width to fit proportionally. This is a key feature for creating full-width tables that need to be responsive and aesthetically balanced in their layout.

This example illustrates how to customize the width of a single columns, while expanding the rest of the table to fill the entire page width:

```{r}
kbl(df,
    tabular = "tblr",
    align = "ccc") |>
    kable_styling(full_width = TRUE) |>
    column_spec(1, width = "8cm")
```

# Cell-specific settings: `cell_spec()`

To apply cell-specific settings, we can use the `cell_spec()` function. In `kbl()`, it is necessary to use `escape=TRUE` and `tabular="tblr"`. In `cell_spec()`, it is necessary to use `tabular="tblr"`:

```{r}
df2 <- df
df2[2, 2] <- cell_spec(
  df2[2, 2],
  background = "pink",
  align = "c",
  color = "azure2",
  font_size = 20,
  angle = 45,
  format = "tblr")

kbl(df2, tabular = "tblr", escape = FALSE)
```

# Extra `tabularray` arguments

The [`tabularray` document describes many other arguments](https://ctan.org/pkg/tabularray?lang=en) which are available to control cells, rows, and columns of a table. For example, the `ht` argument can control the height of a row.

`kableExtra` does not have a `height` argument, but it is possible (and fun) to push through extra (unspecified) `tabularray` arguments through `background` argument. To understand how this works, note that when we call `background="red"`, `kableExtra` simply adds a string to the `rowspec` header: `fg=red`. If we extend the `background` entry, then we can specify height and vertical alignment too (here: using `f` for "foot"):

```{r}
kbl(df, tabular = "tblr") |>
  row_spec(2, background = "pink, ht=1cm, valign=f")
```

# Solved bugs

This section prints several tables which previous included bugs, as reported by `kableExtra` users on the issue tracker. This illustrates that `tabularray` solves many longstanding problems.

## Issue #616

```{r}
mtcars %>%
  head(n = 10) %>%
  kbl(tabular = "tblr") %>%
  kable_styling() |>
  row_spec(seq(1, 10, by = 2), background = "gray8, ht=1cm") |>
  row_spec(seq(2, 10, by = 2), background = "white, ht=1cm")
```

## Issue #634

```{r}
cs_dt <- mtcars[1:10, 1:2]
cs_dt$mpg = cell_spec(cs_dt$mpg, align = "c")
kbl(cs_dt, tabular = "tblr", escape = FALSE) %>%
  kable_styling(latex_options = "striped")
```

## Issue #636

```{r}
set.seed(1024)
paint <- function(x) {
  col <- ifelse(x < 0.5, "yellow", "red")
  sapply(seq_along(x), function(i) cell_spec(
    formatC(x[i], format = "f", digits = 2), background = col[i], format = "tblr")
  )
}
DF <- data.frame(V1 = sample(letters,10,T), V2 = abs(rnorm(10)), V3 = abs(rnorm(10)))
DF[,-1] = lapply(DF[,-1], paint)

kbl(DF, tabular = "tblr", digits = 2, escape = FALSE) |>
  kable_styling(latex_options = "striped")
```

## Issue #645

```{r}
mtcars[1:3, 1:3] |>
  kbl(tabular = "tblr", booktabs = TRUE) |>
  row_spec(0, background = "teal3", bold = TRUE, color = "white")
```

## Issue #660

```{r}
kbl(mtcars[1:7, ], align = "c", tabular = "tblr", booktabs = TRUE, linesep = "") %>%
  kable_styling(latex_options = c("striped", "HOLD_position"), full_width = TRUE) %>%
  column_spec(1, width = "4cm")
```


## Issue #701

```{r}
dt <- data.frame(
  title = c(rep("a", 3), rep("b", 3), rep("c", 3), rep("d", 3)),
  value = 1:12
)
kbl(dt, format = "latex", tabular = "tblr") |>
  collapse_rows(1, latex_hline = "none") |>
  pack_rows(index = c('a' = 3, 'b' = 3, 'c' = 3, 'd' = 3)) |>
  row_spec(c(1, 5, 9, 13), background = "gray8")
```

##  Issue #738

```{r}
t <- head(cars)
t$dist <- cell_spec(t$dist, background = "red", format = "tblr")
kbl(t, tabular = "tblr", escape = FALSE) |> kable_styling(latex_options = c("striped"))
```

# Remaining bugs 

The bugs in this section should be easy to fix now.

## Issue #366

```{r}
groups <- c(3, 3, 5, 4, 3, 3, 3, 2, 3, 2, 3)
groups <- setNames(groups, c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k"))
x <- data.frame(Term = c('Other', 'White', 'Black', '18 to 24', '25 to 39', '40 to 59', 'Married', 'No longer married', 'Never married', 'Living with partner', 'Missing', '0-1', '2-5', '6-10', '11+', '0-1', '2-5', '6+', '0-1', '2-5', '6+', '0-1', '2-5', '6+', 'Yes', 'No', 'Never', 'Ever', 'Missing', 'Never', 'Ever', 'Heterosexual', 'Homosexual/Bisexual', 'Other'),
           uni = c('Ref', '0.87(0.36, 2.1)', '1.3(0.62, 2.7)^', 'Ref', '0.65(0.32, 1.3)', '0.69(0.38, 1.2)', 'Ref', '4.5(1.5, 13.5)**^', '3.8(1.6, 9.1)**^', '2.7(0.86, 8.3)^', '7.1(2.4, 20.7)***', 'Ref', '1.9(0.47, 7.3)^', '2.5(0.89, 6.9)^', '4.1(1.5, 11.6)**^', 'Ref', '4.2(2.2, 7.8)***', '14.1(2.6, 75.9)***^', 'Ref', '1.6(0.81, 3.1)^', '3.7(1.5, 9.2)**^', 'Ref', '2.8(1.2, 6.3)*^', '16.8(3.1, 92.5)***^', 'Ref', '0.59(0.28, 1.2)', 'Ref', '3.2(1.3, 7.9)*^', '6.6(3.3, 13.2)***', 'Ref', '2.7(1.5, 4.9)***', 'Ref', '1.4(0.48, 4.0)^', '0.69(0.16, 3.0)'),
           adj = c('Ref', '0.63(0.21, 1.9)', '0.86(0.40, 1.8)', 'Ref', '1.5(0.43, 5.1)^', '2.1(0.75, 5.9)^', 'Ref', '2.5(0.73, 8.5)^', '2.8(0.79, 9.6)^', '2.0(0.62, 6.4)^', '5.9(1.0, 34.4)^', 'Ref', '0.99(0.14, 7.1)', '0.70(0.16, 3.1)', '0.57(0.11, 3.0)', 'Ref', '3.3(0.87, 12.8)^', '4.2(0.85, 20.3)^', 'Ref', '1.3(0.44, 3.8)^', '2.1(0.47, 9.6)^', 'Ref', '0.65(0.13, 3.2)', '2.6(0.54, 12.5)^', 'NA', 'NA', 'Ref', '2.3(0.81, 6.5)^', '1.8(0.31, 11.1)^', 'Ref', '1.7(0.89, 3.1)^', 'NA', 'NA', 'NA'),
           uni1 = c('Ref', '1.1(0.37, 3.2)^', '0.67(0.19, 2.3)', 'Ref', '0.38(0.16, 0.89)*', '0.61(0.24, 1.5)', 'Ref', '3.5(1.0, 12.5)^', '2.4(0.84, 7.0)^', '1.7(0.34, 8.3)^', '8.0(2.5, 25.4)***', 'Ref', '1.2(0.23, 6.5)^', '2.5(0.81, 7.8)^', '4.1(1.3, 13.3)*^', 'Ref', '4.4(2.1, 9.3)***', '18.2(2.8, 120.2)***^', 'Ref', '2.9(0.96, 8.7)^', '6.0(1.9, 18.6)***^', 'Ref', '3.8(1.4, 10.4)*^', '22.5(3.2, 155.8)***^', 'Ref', '0.99(0.33, 3.0)', 'Ref', '4.8(1.8, 12.6)***^', '12.0(5.3, 27.1)***', 'Ref', '3.3(1.4, 7.9)*^', 'Ref', '0.98(0.24, 4.0)', '1.0(0.24, 4.6)^'),
           adj1 = c('Ref', '0.73(0.22, 2.5)', '0.47(0.14, 1.6)', 'Ref', '0.88(0.15, 5.2)', '1.9(0.48, 7.6)^', 'Ref', '1.7(0.48, 6.0)^', '1.8(0.39, 8.0)^', '1.2(0.28, 5.5)^', '6.5(0.95, 44.8)^', 'Ref', '0.36(0.06, 2.2)', '0.41(0.09, 1.8)', '0.36(0.08, 1.7)', 'Ref', '3.2(0.45, 23.2)^', '4.6(0.55, 38.9)^', 'Ref', '3.0(0.75, 12.0)^', '3.1(0.54, 18.1)^', 'Ref', '0.95(0.11, 8.0)', '3.3(0.41, 26.8)^', 'NA', 'NA', 'Ref', '3.3(1.3, 8.1)*^', '1.9(0.27, 13.1)^', 'Ref', '1.4(0.70, 2.9)^', 'NA', 'NA', 'NA'))

kbl(x, tabular = "tblr", row.names = FALSE) |>
  kable_styling(latex_options = c("striped", "scale_down")) |> 
  group_rows(index = groups) 
```

## Issue #571

Notes:

* Striping does not take groups into account, but at least the indentation works.

```{r}
kbl(mtcars[1:10, 1:6], tabular = "tblr") |>
  pack_rows("Group 1", 4, 7) |>
  pack_rows("Group 2", 8, 10) |>
  kable_styling(latex_options = c("striped"))
```